<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Start 3D
d3d_start();
d3d_set_lighting(true);
d3d_light_define_ambient(make_color_rgb(8, 8, 24));
d3d_light_define_direction(0, 1, -1, 1, make_color_rgb(256, 196, 196));
d3d_light_define_direction(1, 0, -1, 0, c_white);
d3d_light_enable(0, true);
d3d_light_enable(1, true);

// This is our "render buffer".
// We render to this then push it to the display surfaces:
_mainSurface = surface_create(HMD.hresolution , HMD.vresolution);

// This is our world model:
_model = d3d_model_create();
var __max = 4096; // Max number of cubes to add
for (var i = 0; i &lt; __max; ++i)
{
    var __x = random_range(-24, 24),
        __y = random_range(-24, 24),
        __z = random_range(-24, 24),
        __s = random_range(0.01, 0.25);
    d3d_model_block(_model, __x, __y, __z, __x + __s, __y + __s, __z + __s, 1, 1);
}

_triangles = 12 * __max + 12; // For debugging, record poly-count

_controllerModel = d3d_model_create();
d3d_model_block(_controllerModel, -0.03, -0.03, -0.02, 0.03, 0.03, 0.14, 1, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Cleanup
if (!vrObj._vrStarted)
    exit;
    
if (surface_exists(_mainSurface))
    surface_free(_mainSurface);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Chaperone state
if (vr_get_chaperonestate() != VR_CHAPERONE_STATE.ok)
{
    d3d_set_projection_ortho(0, 0, room_width, room_height, 0);
    draw_clear(c_black);
    draw_set_color(c_white);
    draw_set_valign(fa_center);
    draw_set_halign(fa_center);
    
    draw_text(room_width / 2, room_height / 2, "The chaperone is reporting an error!" + 
              "##You have two possibilities:#   1) SteamVR is still booting#   2) You have a problem with your VR setup");
    
    draw_set_valign(fa_top);
    draw_set_halign(fa_left);
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Render Each Eye
draw_clear(c_black);

// Store old matrices:
var __vmat = matrix_get(matrix_view),
    __pmat = matrix_get(matrix_projection),
    __wmat = matrix_get(matrix_world);
    
// Block properties:
var __color = c_white;
var __fxaaStrength = 2;
var __controllers = vr_get_controllercount();
draw_set_color(__color);

if (!surface_exists(_mainSurface))
    _mainSurface = surface_create(HMD.hresolution, HMD.vresolution);
    
// Render left eye to buffer surface:
surface_set_target(_mainSurface);
draw_clear(c_black);
vr_set_render_left(0.01, 50);
    // Render interactives
with (interactiveObj)
{ 
    if (_selected == 0)
    {
        d3d_set_lighting(true);
        draw_set_color(c_white);
    }
    if (_selected &gt; 0)
    {
        d3d_set_lighting(false);
        draw_set_color(c_lime);
    }
    d3d_draw_ellipsoid(_x - _size, _y - _size, _z - _size, _x + _size, _y + _size, _z + _size, -1, -1, -1, 32);
    d3d_set_lighting(true);
    draw_set_color(c_white);
}
    
    // Render World
draw_set_color(c_white);
d3d_model_draw(_model, 0, 0, 0, -1);
d3d_set_lighting(false);

    // Draw the controllers:
draw_set_color(c_red);
for (var i = 0; i &lt; __controllers; ++i)
{
    var __m = vr_get_matrix_controller(i + 1);
    if (!is_undefined(__m))
    {
        matrix_set(matrix_world, __m);
        d3d_model_draw(_controllerModel, 0, 0, 0, -1);
    }
    else
        show_debug_message("ERROR: Failed to get controller matrix: " + string(i + 1));
}
matrix_set(matrix_world, __wmat);
draw_set_color(c_white);

surface_reset_target();

// Push to display surface:

vr_surface_set_left();
shader_set(fxaaShd);
shader_set_uniform_f(shader_get_uniform(fxaaShd, "u_iStrength"), __fxaaStrength);
shader_set_uniform_f(shader_get_uniform(fxaaShd, "u_vTexelSize"), 
                     texture_get_texel_width(surface_get_texture(_mainSurface)),
                     texture_get_texel_height(surface_get_texture(_mainSurface)));
draw_surface(_mainSurface, 0, 0);
shader_reset();
surface_reset_target();

// Render right eye to application surface:
surface_set_target(_mainSurface);
draw_clear(c_black);
vr_set_render_right(0.01, 50);
    // Render interactives
with (interactiveObj)
{ 
    if (_selected == 0)
    {
        d3d_set_lighting(true);
        draw_set_color(c_white);
    }
    if (_selected &gt; 0)
    {
        d3d_set_lighting(false);
        draw_set_color(c_lime);
    }
    d3d_draw_ellipsoid(_x - _size, _y - _size, _z - _size, _x + _size, _y + _size, _z + _size, -1, -1, -1, 32);
    d3d_set_lighting(true);
    draw_set_color(c_white);
}
    // Render World
d3d_model_draw(_model, 0, 0, 0, -1);
d3d_set_lighting(false);

    // Draw the controllers:
draw_set_color(c_red);
for (var i = 0; i &lt; __controllers; ++i)
{
    var __m = vr_get_matrix_controller(i + 1);
    if (!is_undefined(__m))
    {
        matrix_set(matrix_world, __m);
        d3d_model_draw(_controllerModel, 0, 0, 0, -1);
    }
    else
        show_debug_message("ERROR: Failed to get controller matrix: " + string(i + 1));
}
matrix_set(matrix_world, __wmat);
draw_set_color(c_white);

surface_reset_target();

// Push to display surface:
vr_surface_set_right();
shader_set(fxaaShd);
shader_set_uniform_f(shader_get_uniform(fxaaShd, "u_iStrength"), __fxaaStrength);
shader_set_uniform_f(shader_get_uniform(fxaaShd, "u_vTexelSize"), 
                     texture_get_texel_width(surface_get_texture(_mainSurface)),
                     texture_get_texel_height(surface_get_texture(_mainSurface)));
draw_surface(_mainSurface, 0, 0);
shader_reset();
surface_reset_target();

matrix_set(matrix_view, __vmat);
matrix_set(matrix_projection, __pmat);

draw_set_color(c_white);
vr_update_textures(); // Push textures from GameMaker to DLL
vr_update_display();  // Push textures from DLL to HMD
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
